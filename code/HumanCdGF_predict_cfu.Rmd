---
title: "humanCdGF_predict_cfu"
author: "Nicholas Lesniak"
date: "October 7, 2016"
output: html_document
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message=FALSE, fig.width=7, fig.height=8)
```

```{r setup environment}
pack_used <- c('randomForest','miscTools','tidyr','ggplot2','dplyr', 'pROC', 'knitr', 'cowplot')
for (dep in pack_used){
  if (dep %in% installed.packages()[,"Package"] == FALSE){
    install.packages(as.character(dep), repos = 'http://cran.us.r-project.org', 
                     quiet=TRUE);
  }
  library(dep, verbose=FALSE, character.only=TRUE)
}
```

```{r setup data}
# read in files
meta_data   <- '~/Documents/Github/Schubert_humanCdGF_XXXX_2016/data/process/human_CdGF_metadata.txt'
shared_file <- '~/Documents/Github/Schubert_humanCdGF_XXXX_2016/data/process/human_CdGF.an.unique_list.0.03.subsample.shared'
tax_file <- '~/Documents/Github/Schubert_humanCdGF_XXXX_2016/data/mothur/gf_all.an.cons.taxonomy'
tax_function <- '~/Documents/Github/Schubert_humanCdGF_XXXX_2016/code/tax_level.R'

# read in files
meta_data   <- read.table(meta_data, sep = '\t', header = T, stringsAsFactors = F)
shared_file <- read.table(shared_file, sep = '\t', header = T, row.names = 'sample_id')
tax_file <- read.table(tax_file, sep = '\t', header = T, row.names = 'OTU')
source(tax_function)

# remove samples not used or with other cdiff strains
meta_file <- 
  meta_data %>% 
  filter(Early_Euth == FALSE, cdiff_strain == 431, !cage_id == 'NP1') %>% 
  select(mouse_id, sample_id, day, log_cfu) %>% 
  filter(!is.na(log_cfu))

shared_list_days <- select(meta_file, -log_cfu)

# create shared with relative abundances over 1%
mean_otu_counts <- unique(apply(shared_file, 1, sum))
rel_abund_shared <- 100 * shared_file / mean_otu_counts
rel_abund_shared_01 <- rel_abund_shared[ , apply(rel_abund_shared, 2, max) > 1]
rel_abund_shared_01$sample_id <- rownames(rel_abund_shared_01)

seed <- 1
n_trees <- 1001

```

### Reframing the question for predicting CFU
#### 1. Can Day 0 community predict the median steady-state-colonized CFU?

```{r predict median CFU, fig.width=10,fig.height=10}

colonized_cfu <- meta_data %>% 
  filter(day %in% c(4:10), !cage_id == 'NP1', 
         Early_Euth == FALSE, cdiff_strain == 431) %>% 
  select(mouse_id, cage_id, log_cfu) %>% 
  group_by(mouse_id, cage_id) %>% 
  summarise(log_cfu_med = median(log_cfu)) %>% 
  ungroup()
sample_list_d0 <- shared_list_days %>% 
    filter(day == 0) %>% 
    select(-day)
community_d0.df <- rel_abund_shared_01 %>% 
    right_join(sample_list_d0) %>% 
    select(-sample_id)
cfu_shared_colonized.df <- colonized_cfu %>% 
    right_join(community_d0.df) %>% 
    select(-mouse_id, -cage_id) %>% 
    filter(!is.na(log_cfu_med))

##### feature reduction #####
### boruta
set.seed(seed)
rf_features <- Boruta(log_cfu_med ~ ., data = cfu_shared_colonized.df, maxRuns = 2000)
boruta_otus <- names(rf_features$finalDecision)[rf_features$finalDecision == 'Confirmed']
set.seed(seed)
rf_boruta <- randomForest(log_cfu_med ~ ., data = cfu_shared_colonized.df[, c('log_cfu_med', boruta_otus)],
                           importance = TRUE, ntree = n_trees)
### above mean features, reiteratively reduce to 2 otus 
###### used mean because median results in including many low values in early OTU selection steps
rf_rsq <- c()
otus_used <- c()
rf_otus <- colnames(cfu_shared_colonized.df)[-1]
for(i in 1:100){
  if(length(rf_otus) > 1){
  set.seed(seed)
  rf <- randomForest(log_cfu_med ~ ., data = cfu_shared_colonized.df[, c('log_cfu_med', rf_otus)],
                     importance = TRUE, ntree = n_trees)
  rf_import_otus <- importance(rf, type = 1)
  otus_used[[i]] <- rf_otus
  rf_otus <- rownames(rf_import_otus)[rf_import_otus >= mean(rf_import_otus)]
  rf_rsq[i] <- tail(rf$rsq, 1)
  } else {
    set.seed(seed)
    rf <- randomForest(log_cfu_med ~ ., data = cfu_shared_colonized.df[, c('log_cfu_med', rf_otus)],
                       importance = TRUE, ntree = n_trees)
    otus_used[[i]] <- rf_otus
    rf_rsq[i] <- tail(rf$rsq, 1)
    stop('Only one OTU remains')
  }
}
#### select top otus from reiteration through RF
optimum_otus <- otus_used[[which(rf_rsq == max(rf_rsq))]]
reduced_otus <- otus_used[[3]]

### test models with top subset of otus
top_important_OTU <- optimum_otus
top_colonized_df <- data.frame(cfu_shared_colonized.df %>% 
  select(log_cfu_med, one_of(top_important_OTU)))

set.seed(seed)
rf_n_features <- randomForest(log_cfu_med ~ ., data=top_colonized_df,
                              importance=TRUE, ntree=n_trees, keep.forest=TRUE)

importance_final <- sort(importance(rf_n_features)[,1], decreasing = T)

rf_prediction <- data.frame(observed = cfu_shared_colonized.df$log_cfu_med, 
                       predicted = rf_n_features$predicted)
rf_prediction <- merge(rf_prediction, colonized_cfu, by.x = 'observed', by.y = 'log_cfu_med')

##### - leave one cage out cv
LOcO_df <- data.frame(colonized_cfu %>% 
    right_join(community_d0.df) %>% 
    filter(!is.na(log_cfu_med)) %>% 
    select(log_cfu_med, mouse_id, cage_id, one_of(top_important_OTU)))
cage_list <- unique(LOcO_df$cage_id)

LOcO_probs <- c()
rsq <- c()
import_otus <- data.frame(otu = top_important_OTU)
for(i in 1:length(cage_list)){
  by_cage <- LOcO_df$cage_id == cage_list[i]
  LOcO_predict <- select(LOcO_df, -cage_id, -mouse_id)
  train <- LOcO_predict[!by_cage,]
  test <- LOcO_predict[by_cage,]
  set.seed(seed)
  temp_model <- randomForest(log_cfu_med~., data=train, pdel=0.99, ntree=500, importance=T)
  import_df <- importance(temp_model)
  colnames(import_df)[1] <- cage_list[i]
  import_otus <- merge(import_otus, import_df, by.x = 'otu', by.y = 'row.names')
  import_otus <- select(import_otus, -IncNodePurity)
  rsq[i] <- round(tail(temp_model$rsq, 1), 2)
  LOcO_probs <- rbind(LOcO_probs, data.frame(observed=test$log_cfu_med, 
                                             predicted=predict(temp_model, test),
                                             mouse_id=LOcO_df$mouse_id[by_cage],
                                             cage_id=rep(cage_list[i], nrow(test))))
}
med_otu_importance <- data.frame(otu = import_otus$otu,
                                 importance = apply(import_otus[, -1], 1, median))
med_otu_importance <- med_otu_importance[order(med_otu_importance$importance, decreasing = T),]

LOcO_rsq <- 1 - (sum((LOcO_probs$observed - LOcO_probs$predicted)^2)/
                   sum((LOcO_probs$observed - mean(LOcO_probs$observed))^2))

#One per cage
one_mouse_df <- data.frame(colonized_cfu %>% 
    right_join(community_d0.df) %>% 
    filter(!is.na(log_cfu_med))  %>% 
    select(log_cfu_med, mouse_id, cage_id, contains('Otu')))

om_rsq_rf <- c() # rsq of each rf model
om_rsq <- c() # cumulative rsq of all models
om_import_otus <- data.frame(otu = colnames(select(one_mouse_df, contains('Otu'))))
one_df <- c()
om_pred <- c()
for(i in 1:20){
    set.seed(i)
    train <- one_mouse_df %>% 
      group_by(cage_id) %>% 
      sample_n(1) %>% ungroup() 
    test <- one_mouse_df %>% 
      filter(!mouse_id %in% train$mouse_id)
    set.seed(seed)
    rf_om <- randomForest(log_cfu_med ~ ., data = select(train, -mouse_id, -cage_id),
                             importance = TRUE, keep.forest = T, ntree = n_trees)
    om_rsq_rf[i] <- tail(rf_om$rsq, 1)
    om_pred <- rbind(om_pred,
                     data.frame(select(test, mouse_id, cage_id, log_cfu_med),
                          predicted=predict(rf_om, test)))
    om_rsq[i] <- 1 - (sum((om_pred$log_cfu_med - om_pred$predicted)^2)/
               sum((om_pred$log_cfu_med - mean(om_pred$log_cfu_med))^2))
    import_df <- importance(rf_om)
    colnames(import_df)[1] <- paste(train$mouse_id, collapse = ' ')
    om_import_otus <- merge(om_import_otus, import_df, by.x = 'otu', by.y = 'row.names')
    om_import_otus <- select(om_import_otus, -IncNodePurity)
}
test <- data.frame(om_import_otus[ , -1], row.names = om_import_otus$otu)
colnames(test) <- seq(ncol(test))

test_mean <- apply(test, 2, function(x) mean(x, na.rm=T)) # mean importance for each rf model
test_select <- apply(test, 1, function(x) x >= test_mean) # T for each otu above mean by sample
test_raw_mean <- apply(test_select, 2, function(x) sum(x[!is.na(x)])/length(x[!is.na(x)])) # portion of rf model otu is above mean imp
test_import_mean <- sort(test_raw_mean[test_raw_mean > 0.5], decreasing = T)

#### median with 
test_med <- apply(test, 2, function(x) median(x, na.rm=T)) # median importance for each rf model
test_select <- apply(test, 1, function(x) x >= test_med) # T for each otu above median by sample
test_raw_med <- apply(test_select, 2, function(x) sum(x[!is.na(x)])/length(x[!is.na(x)])) # portion of rf model otu is above med imp
test_import_med <- sort(test_raw_med[test_raw_med > 0.5], decreasing = T)

test_rank <- apply(test, 2, function(x) rank(x))
test_raw_rank <- apply(test_rank, 1, function(x) sum(x, na.rm = T))
sort(test_import_rank[test_raw_rank >=  ncol(test_rank)*sum(test_rank[ , 1])/nrow(test_rank)], decreasing = T)

#####
test <- c() # test if any model has same train set
  for(i in 2:21){
  test[i-1] <- colnames(om_import_otus)[i] %in% colnames(om_import_otus)[-c(1,i)]
}
any(test) # if true, then trained on the same set of mice multiple times
#####

om_pred <- rename(om_pred, observed = log_cfu_med)

med_otu_importance_om <- data.frame(otu = om_import_otus$otu,
                                 importance = apply(om_import_otus[, -1], 1, median))
med_otu_importance_om <- med_otu_importance_om[order(med_otu_importance_om$importance, decreasing = T),]

#### merge OOB and leave 1 cage out dataframes
all_rf <- rbind(cbind(rf_prediction, data = rep('OOB', nrow(rf_prediction))),
                cbind(LOcO_probs, data = rep('LOO', nrow(LOcO_probs))),
                cbind(om_pred, data = rep('1_mouse', nrow(om_pred))))

ggplot(data = all_rf, aes(x=observed, y=predicted, color = data)) + geom_point() + 
  geom_abline(slope = 1) + 
  xlim(c(4,9)) + ylim(c(4,9)) +
  labs(x= 'Observed Log10 CFU', y = 'Predicted Log10 CFU',
       title = "Random Forest Prediction of Colonized C Difficile CFU from Day 0 Community") + 
  theme_bw() + annotate('text', x=1.05*(min(LOcO_probs$observed)), 
                        y=0.95*(max(LOcO_probs$predicted)), # parse = T,
                        label=paste0('OOB ', 'R^2 == ', round(tail(rf_n_features$rsq, 1), 2),
                                     '\nLOcO ','R^2 == ', round(LOcO_rsq, 2),
                                     '\n1 mouse', 'R^2 == ', round(tail(om_rsq, 1), 2))) + 
  theme(legend.position = 'none')

get_tax(1, med_otu_importance$otu, tax_file)
##### - leave one cage out cv


ggplot(data = rf_prediction, aes(x=observed, y=predicted, color = cage_id)) + geom_point() + 
  labs(x= 'Observed CFU (log10)', y = 'Predicted CFU (log10)',
       title = "Random Forest Prediction of Colonized C Difficile CFU from Day 0 Community") + 
  theme_bw() + annotate('text', x=1.05*(min(rf_prediction$observed)), 
                        y=0.95*(max(rf_prediction$predicted)), parse = T,
                        label=paste0('R^2 == ', round(tail(rf_n_features$rsq, 1), 2))) + 
  theme(legend.position = 'none')

importance.df <- data.frame(get_tax(1, names(importance_final), tax_file),
                            importance = importance_final)
tax_label <- paste0(importance.df$tax_label, ' : ', 
                    round(importance.df$importance, 3))

layout(matrix(c(1:9), ncol=3, byrow=TRUE))

cage_color <- rainbow(length(unique(rf_prediction$cage_id)))
for (i in seq_along(importance_final)) {
    partialPlot(rf_n_features, top_colonized_df, names(importance_final)[i],
                xlab='', main=paste(tax_label[i]))
    par(new = T)
    plot(y = top_colonized_df[ , 'log_cfu_med'],
         x = top_colonized_df[ , names(importance_final)[i]], 
         pch = 21, bg = 'gray', xlab = NA, ylab = NA, axes = F)
    axis(side = 4)
    mtext(side = 4, line = 3, 'Log10 CFU')
# To color points by cage - Change pch to 21 and un-comment following lines
#  for(m in seq_along(unique(rf_prediction$cage_id))){
#    cage <- unique(rf_prediction$cage_id)[m]
#    points(y = top_colonized_df[rf_prediction$cage_id %in% cage, 'log_cfu_med'],
#         x = top_colonized_df[rf_prediction$cage_id %in% cage , names(importance_final)[i]], 
#         pch = 21, bg = cage_color[m], xlab = NA, ylab = NA, axes = F)
#  }
}

```


#### 2. Can Day 0 community predict the rate of colonization?

```{r predict colonization rate, fig.width=10,fig.height=10}

meta_data %>% 
  filter(!is.na(day), !cage_id == 'NP1', 
         Early_Euth == FALSE, cdiff_strain == 431) %>% 
  ggplot(aes(x = factor(day), y = log_cfu, color = cage_id)) + 
    geom_line(aes(group = mouse_id), size=.25, alpha=0.4) + geom_point() +
    stat_summary(fun.y=mean, geom="line", aes(group = cage_id)) + 
    theme_bw() + labs(x = 'Day', y = 'C Diff CFU (log10)') +
    theme(legend.justification=c(1,0), legend.position=c(1,0), 
          legend.title=element_blank())

mouse_list <- meta_data %>% 
  filter(!is.na(day), !cage_id == 'NP1', 
         Early_Euth == FALSE, cdiff_strain == 431) %>% 
  select(mouse_id) %>% 
  unique()
mouse_list <- as.character(mouse_list$mouse_id)

col_rate <- c()
for(i in mouse_list){
  test <- meta_data %>% 
    filter(!is.na(day), mouse_id == i) %>% 
    select(day, log_cfu) %>% 
    filter(!is.na(log_cfu))
  if(1 %in% test$day){
    colonization_ratio <- test[test$day==1, 'log_cfu']/median(head(sort(test$log_cfu, decreasing = T),3))
  } else {
    colonization_ratio <- median(head(test[order(test$day), "log_cfu"],2))/
                            median(head(sort(test$log_cfu, decreasing = T),3))
  }
  col_rate <- rbind(col_rate, c(mouse_id = i,  ratio = colonization_ratio))
}

col_rate <- data.frame(mouse_id = col_rate[ , 1], ratio = as.numeric(col_rate[ , 2]))

col_rate <- meta_data %>% 
  select(mouse_id, cage_id) %>% 
  unique() %>% 
  right_join(col_rate)

shared_col_rate.df <- col_rate %>% 
    right_join(community_d0.df)
shared_colonized.df <- select(shared_col_rate.df, -mouse_id, -cage_id)


set.seed(seed)
rf_col_rate <- randomForest(ratio ~ ., data = shared_colonized.df,
                           importance = TRUE, ntree = n_trees, mtry = 14)

importance_sorted <- sort(importance(rf_col_rate)[,1], decreasing = T)
top_important_OTU <- rownames(data.frame(importance_sorted[importance_sorted/max(importance_sorted) > 0.6]))

top_col_rate_df <- data.frame(shared_colonized.df %>% 
  select(ratio, one_of(top_important_OTU)))

set.seed(seed)
rf_col_rate_features <- randomForest(ratio ~ ., data=top_col_rate_df,
                              importance=TRUE, ntree=n_trees, mtry = 2,
                              keep.forest=TRUE)

importance_final <- sort(importance(rf_col_rate_features)[,1], decreasing = T)

rf_col_rate_prediction <- data.frame(observed = shared_colonized.df$ratio, 
                       predicted = rf_col_rate_features$predicted)
rf_cr_prediction <- cbind(cage_id = shared_col_rate.df[,'cage_id'], rf_col_rate_prediction)

ggplot(data = rf_cr_prediction, aes(x=observed, y=predicted, color = cage_id)) + geom_point() + 
  labs(x= 'Observed', y = 'Predicted',
       title = "Random Forest Prediction of Relative Day 1 Colonization Level of C. Difficile from Day 0 Community") + 
  theme_bw() + xlim(0,1) + ylim(0,1) + 
  annotate('text', x=0.15*(max(rf_cr_prediction$observed)), 
           y=0.95*(max(rf_cr_prediction$predicted)), parse = T,
           label=paste("R^2 == ", round(tail(rf_col_rate_features$rsq, 1), 2))) + 
  theme(legend.position = 'none')

importance.df <- data.frame(otu = names(importance_final),
                            importance = importance_final,
                            tax = get_tax(1, names(importance_final), tax_file))
tax_label <- paste0(importance.df$tax, ' (', 
                    gsub('tu0*', 'TU ', importance.df$otu), 
                    ') : ', 
                    round(importance.df$importance, 3))

layout(matrix(c(1:9), ncol=3, byrow=TRUE))

cage_color <- rainbow(length(unique(rf_cr_prediction$cage_id)))
for (i in seq_along(importance_final)) {
    partialPlot(rf_col_rate_features, top_col_rate_df, names(importance_final)[i],
                xlab='', main=paste(tax_label[i]))
    par(new = T)
    plot(y = top_col_rate_df[ , 'ratio'],
         x = top_col_rate_df[ , names(importance_final)[i]], 
         pch = 21, bg = 'gray', xlab = NA, ylab = NA, axes = F)
    axis(side = 4)
    mtext(side = 4, line = 3, 'Relative Colonization')
# To color points by cage - Change pch to 21 and un-comment following lines
#  for(m in seq_along(unique(rf_cr_prediction$cage_id))){
#    cage <- unique(rf_cr_prediction$cage_id)[m]
#    points(y = top_col_rate_df[rf_cr_prediction$cage_id %in% cage, 'ratio'],
#         x = top_col_rate_df[rf_cr_prediction$cage_id %in% cage , names(importance_final)[i]], 
#         pch = 21, bg = cage_color[m])
#  }
}
```

Does not predict colonization rate as well  
  - could be due to removed (cage/inocula-sensitive) otus  
  - improper measurement of colonization rate  
  - colonization rate not microbiome dependent, may be dependent on host factors of acute infection

***  
  
***  